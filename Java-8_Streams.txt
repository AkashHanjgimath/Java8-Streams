
Java Stream API - Comprehensive Notes

The Java Stream API, introduced in Java 8, provides a functional and declarative way to process collections and arrays with powerful operations like filtering, mapping, reducing, sorting, and collecting.

--------------------------------------------------
Stream Creation
--------------------------------------------------
1. From Collections:
   list.stream()             // Sequential stream
   list.parallelStream()     // Parallel stream

2. From Arrays:
   Arrays.stream(array)

3. From Range of Numbers:
   IntStream.range(1, 10)         // 1 to 9
   LongStream.rangeClosed(1, 10)  // 1 to 10

4. From Suppliers:
   Stream.generate(() -> Math.random()).limit(5)
   Stream.iterate(1, n -> n + 1).limit(5)

5. From I/O:
   BufferedReader br = new BufferedReader(...);
   Stream<String> lines = br.lines();

--------------------------------------------------
Intermediate Operations (Lazy Execution)
--------------------------------------------------
- filter(Predicate)         -> Filters elements by condition
- map(Function)             -> Transforms elements
- flatMap(Function)         -> Flattens nested streams
- sorted() / sorted(Comparator) -> Sorts elements
- limit(n) / skip(n)        -> Truncates or skips elements
- distinct()                -> Removes duplicates

Examples:
   list.stream().filter(e -> e > 10)
   list.stream().map(String::toUpperCase)
   list.stream().flatMap(Collection::stream)
   list.stream().sorted()
   list.stream().sorted(Comparator.reverseOrder())
   list.stream().limit(3)
   list.stream().skip(2)
   list.stream().distinct()

--------------------------------------------------
Terminal Operations
--------------------------------------------------
- collect(Collector)        -> Collects elements into collection
- reduce(identity, BinaryOperator) -> Combines elements
- count(), max(), min(), average(), sum() -> Aggregation
- forEach(Consumer)         -> Performs action on each element
- anyMatch(), allMatch(), noneMatch() -> Matching
- findFirst(), findAny()    -> Finding elements
- toArray(), toList()       -> Conversion
- groupingBy(), partitioningBy() -> Grouping/Partitioning
- joining(delimiter)        -> Joining strings
- mapToInt(), mapToLong(), mapToDouble() -> Primitive streams

Examples:
   list.stream().collect(Collectors.toList())
   list.stream().reduce(0, Integer::sum)
   list.stream().count()
   list.stream().forEach(System.out::println)
   list.stream().anyMatch(e -> e > 10)
   list.stream().findFirst()
   list.stream().collect(Collectors.groupingBy(...))
   list.stream().collect(Collectors.joining(", "))
   list.stream().mapToInt(Integer::intValue)

--------------------------------------------------
Stream Pipeline Structure
--------------------------------------------------
- Pipeline = Source + Intermediate Ops + Terminal Op
- Intermediate operations are lazy – only evaluated at terminal operation.
- Use parallel() or parallelStream() for parallel execution.

--------------------------------------------------
Performance Tips
--------------------------------------------------
- Streams offer lazy evaluation, short-circuiting, and internal iteration.
- Use primitive streams to avoid boxing/unboxing.
- Avoid stateful intermediate ops that depend on shared mutable state.
- Use parallel streams cautiously – only when performance gain is certain.

--------------------------------------------------
Exception Handling in Streams
--------------------------------------------------
- Streams don’t throw checked exceptions directly.
- Use try-catch inside lambda when necessary:

  list.stream().map(e -> {
      try {
          return riskyOperation(e);
      } catch (Exception ex) {
          throw new RuntimeException(ex);
      }
  });

--------------------------------------------------
Common Use Cases
--------------------------------------------------
- Filtering & Transformation
- Aggregation & Summarization
- Searching & Matching
- Sorting & Comparing
- Grouping & Partitioning
- IO & File Processing


--------------------------------------------------
What is boxed()?
--------------------------------------------------
- The boxed() method is used in Java 8 Streams to convert a primitive stream (IntStream, LongStream, DoubleStream)
  into a Stream of their corresponding wrapper classes (Stream<Integer>, Stream<Long>, Stream<Double>).
- This is necessary when you want to use stream collectors like Collectors.toList() which operate on object streams.

--------------------------------------------------
Why use boxed()?
--------------------------------------------------
- Primitive streams like IntStream, LongStream, and DoubleStream do not support collectors like Collectors.toList() directly.
- boxed() wraps the primitive values into their object counterparts so they can be collected into collections like List, Set, etc.

--------------------------------------------------
Example
--------------------------------------------------
int[] arr = {1, 2, 3};

// Incorrect: Compilation error
// List<Integer> list = Arrays.stream(arr).collect(Collectors.toList());

// Correct: Use boxed() to convert IntStream to Stream<Integer>
List<Integer> list = Arrays.stream(arr)
                           .boxed()
                           .collect(Collectors.toList());

--------------------------------------------------
When to use boxed()
--------------------------------------------------
- Whenever you're working with primitive streams and need to:
  - Collect values into a collection like List, Set, etc.
  - Use intermediate/terminal operations that expect object streams

--------------------------------------------------
Conversions Summary
--------------------------------------------------
IntStream    -> boxed() -> Stream<Integer>
LongStream   -> boxed() -> Stream<Long>
DoubleStream -> boxed() -> Stream<Double>

--------------------------------------------------
Note
--------------------------------------------------
- boxed() performs boxing (primitive to wrapper) which may have a slight performance cost.
- Prefer primitive streams for performance-sensitive operations unless object-based operations are necessary.
